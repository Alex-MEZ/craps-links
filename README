Описание проекта:

Проект представляет собой веб-сервис для сокращения URL-ов. Это позволяет пользователям создавать короткие и удобные ссылки для доступа к длинным URL-ам. Сокращенные URL-ы легче использовать и обмениваться.

Цель проекта:

- Упростить работу с длинными URL-ами.
- Предоставить возможность создавать и управлять сокращенными ссылками.
- Собирать статистику по использованию ссылок.

2. Архитектура проекта

Основные компоненты:
- Модель `Token` для хранения сокращенных URL-ов.
- Форма `URLForm` для ввода оригинальных URL-ов.
- Сериализатор `TokenSerializer` для работы с данными модели.
- Представления (Views) для обработки запросов.

Взаимодействие между компонентами:
- Форма используется в представлениях для валидации и сохранения оригинальных URL-ов в модели.
- Сериализатор преобразует объекты модели в JSON и обратно.
- Представления обрабатывают HTTP-запросы, включая создание сокращенных URL-ов и перенаправление пользователей.

В файле `serializers.py` я создал сериализатор `TokenSerializer`, который используется для сериализации и десериализации объектов модели `Token`. Давайте рассмотрим, что я сделал в этом файле:

1. Я импортировал `serializers` и `status` из модуля `rest_framework`.
2. В классе `TokenSerializer` я определил следующее:
   - `class Meta`: В метаклассе `Meta` я указал модель, с которой работает этот сериализатор (`model = Token`). Я также включил все поля модели в сериализацию (`fields = '__all__'`) и установил дополнительные параметры для поля `full_url` с пустым списком валидаторов (`extra_kwargs = {'full_url': {'validators': []}}`).

   - `create(self, validated_data)`: Я переопределил метод `create`, который исполняется при создании нового объекта `Token` через сериализатор. В этом методе я извлекаю `full_url` из `validated_data`. Затем пытаюсь извлечь `short_url` из `validated_data` и, если он присутствует, создаю объект `Token` с обоими значениями (`full_url` и `short_url`). Если `short_url` не указан, создается объект `Token` только с `full_url`. В зависимости от того, был ли объект создан ил уже существует, я устанавливаю соответствующий `status_code` и возвращаю объект `Token` и `status_code`.

Этот сериализатор позволяет нам создавать новые объекты `Token` и сериализовать их данные для использования в вашем API.

Я предоставил файл `settings.py` для Django-проекта. Давайте рассмотрим, что я в нем сделал:

1. `SECRET_KEY = get_random_secret_key()`: Я использую функцию `get_random_secret_key()` для генерации случайного секретного ключа Django. Этот ключ используется для шифрования данных и обеспечения безопасности вашего проекта.

2. `DEBUG = True`: Включен режим отладки. Это удобно во время разработки, но не рекомендуется для использования в продакшн-среде, так как может предоставлять злоумышленникам дополнительную информацию об ошибках.

3. `ALLOWED_HOSTS`: Я разрешаю доступ к вашему проекту с указанными хостами. Звездочка `*` означает, что ваш проект доступен с любых хостов, что может быть опасным с точки зрения безопасности. Рекомендуется ограничить список разрешенных хостов только необходимыми.

4. `INSTALLED_APPS`: Здесь я указываю установленные приложения Django, включая стандартные приложения и свое приложение "api".

5. `DATABASES`: Я настроил базу данных SQLite3 для вашего проекта. Обратите внимание, что SQLite3 удобно использовать для разработки, но в продакшн-среде часто используют более мощные базы данных.

6. `AUTH_PASSWORD_VALIDATORS`: Я настроил набор валидаторов паролей для учетных записей пользователей, чтобы убедиться, что пароли имеют минимальную длину, не слишком похожи на атрибуты пользователя и т. д.

7. `LANGUAGE_CODE`, `TIME_ZONE`, `USE_I18N`, `USE_L10N`, `USE_TZ`: Настройки для интернационалзации и времени в вашем проекте.

8. `STATIC_URL`, `STATIC_ROOT`: Я настроил обработку статических файлов в вашем проекте.

9. `CHARACTERS`, `TOKEN_LENGTH`: Эти переменные, вероятно, используются для генерации токенов ил других случайных строк в вашем проекте.

Помните, что безопасность - это сложная и многогранная тема, и этот файл `settings.py` - только одна из частей обеспечения безопасности вашего проекта. Рекомендуется также провести дополнительные шаги по безопасности, такие как обработка данных, контроль доступа и другие меры, в зависимости от конкретных требований вашего проекта.



3. Модель `Token`

Цель модели:

Модель `Token` предназначена для хранения данных о сокращенных URL-ах и их статистики.

Поля модели:
- `full_url`: Полный URL, уникальный и длинный.
- `short_url`: Сокращенный URL, уникальный и короткий.
- `requests_count`: Счетчик запросов к сокращенному URL.
- `created_date`: Дата и время создания записи.
- `is_active`: Флаг активности сокращенного URL-а.

Генерация `short_url`:

- Если `short_url` не указан при создании, он генерируется случайным образом с использованием символов, определенных в настройках проекта, и проверяется на уникальность в базе данных.

В файле `models.py` я определил модель `Token`, которая представляет собой сокращенные URL-ы. Давайте рассмотрим, что я сделал в этом файле:

1. Я создал класс `Token(models.Model)`, который наследуется от `models.Model`. Это означает, что `Token` является моделью Django и будет представлен в базе данных.

2. Внутри класса `Token` я определил следующие поля:

   - `full_url`: Полный URL, который должен быть уникальным (не может повторяться) и представлен в виде поля `models.URLField`.

   - `short_url`: Сокращенный URL, который также должен быть уникальным, имеет ограничение по длине (максимум 20 символов), и может быть пустым (`blank=True`). Он представлен в виде поля `models.CharField`.

   - `requests_count`: Счетчик запросов, представлен в виде поля `models.IntegerField` с значением по умолчанию 0.

   - `created_date`: Дата и время создания записи, автоматически заполняется при создании записи, представлено в виде поля `models.DateTimeField` с `auto_now_add=True`.

   - `is_active`: Поле, указывающее, активен ли сокращенный URL. По умолчанию оно активно, представлено в виде поля `models.BooleanField` с значением по умолчанию `True`.

3. В метаклассе `Meta` я указал, что записи должны быть упорядочены по убыванию `created_date` (`ordering = ('-created_date',)`).

4. В методе `save(self, *args, **kwargs)`, я переопределил стандартный метод сохранения модели. Если `short_url` не указано, то я генерирую случайный `short_url`, состоящий из символов, определенных в настройках `CHARACTERS`, длиной, указанной в `TOKEN_LENGTH`. Я проверяете, что сгенерированный `short_url` уникален в базе данных, и только тогда сохраняете объект.

5. В методе `__str__(self)`, я определил строковое представление объекта `Token`, которое возвращает строку, состоящую из `short_url` и `full_url`.

Эта модель `Token` представляет собой сущность для хранения сокращенных URL-ов и соответствующей информации в базе данных Django.


4. Форма `URLForm`
*Задачи формы:
Форма `URLForm` предназначена для ввода пользователем оригинальных URL-ов.

Поле `original_url`:

- Позволяет пользователю ввести оригинальный URL.
- Ограничение на максимальную длину URL в 2048 символов.

В файле `urls.py` Django я определил маршруты (URL-пути) для моего проекта. Давайте рассмотрим, что я сделал:

1. `path('', include('api.urls'))`: Я указал, что корневой URL-путь (пустой путь) должен быть обработан приложением `api.urls`. Это означает, что все запросы, начинающиеся с корневого пути, будут переданы для обработки в приложение "api".

2. `path('admin/', admin.site.urls)`: Я настроил административный интерфейс Django, доступный по URL-пути `admin/`. Этот путь предоставляет доступ к административной панели, где можно управлять данными и настройками вашего проекта.

3. `path('<str:short_url>', services.redirection)`: Это динамический URL-путь, который ожидает строкояй параметр `short_url`. Когда пользователь вводит URL с каким-то значением после корня вашего проекта, это значение передается в функцию `services.redirection` для дальнейшей обработки. Вероятно, это связано с перенаправлением на другой URL на основе заданного `short_url`.

Обратите внимание, что файл `urls.py` определяет, как URL-запросы будут маршрутизироваться и обрабатываться в вашем Django-проекте. Важно убедиться, что маршруты определены правильно и соответствуют функциональности вашего проекта.


5. Сериализатор `TokenSerializer`

Роль сериализатора:
Сериализатор `TokenSerializer` отвечает за преобразование объектов модели `Token` в JSON и обратно.

Поля сериализатора:

- Сериалзируются все поля модели `Token`.
- Поле `full_url` имеет пустой список валидаторов.

Метод `create`:

- Создает нояй объект `Token` на основе переданных данных.
- Если `short_url` не указан, генерирует его случайным образом.

В файле `serializers.py` я создал сериализатор `TokenSerializer`, который используется для сериализации и десериализации объектов модели `Token`. Давайте рассмотрим, что я сделал в этом файле:

1. Я импортировал `serializers` и `status` из модуля `rest_framework`.

2. В классе `TokenSerializer` я определил следующее:
   - `class Meta`: В метаклассе `Meta` я указал модель, с которой работает этот сериализатор (`model = Token`). Я также включил все поля модели в сериализацию (`fields = '__all__'`) и установил дополнительные параметры для поля `full_url` с пустым списком валидаторов (`extra_kwargs = {'full_url': {'validators': []}}`).

   - `create(self, validated_data)`: Я переопределил метод `create`, который исполняется при создании нового объекта `Token` через сериализатор. В этом методе я извлекаю `full_url` из `validated_data`. Затем пытаюсь извлечь `short_url` из `validated_data` и, если он присутствует, создаю объект `Token` с обоими значениями (`full_url` и `short_url`). Если `short_url` не указан, создается объект `Token` только с `full_url`. В зависимости от того, был ли объект создан ил уже существует, я устанавливаю соответствующий `status_code` и возвращаю объект `Token` и `status_code`.

Этот сериализатор позволяет нам создавать новые объекты `Token` и сериализовать их данные для использования в вашем API.

6. Представления (Views)

Обработка HTTP-запросов:

- Представления обрабатывают GET и POST запросы.
- GET запросы перенаправляют пользователя на оригинальные URL-ы.
- POST запросы создают новые сокращенные URL-ы.

В вашем файле `views.py` я определил две функции представления для вашего Django-проекта. Давайте рассмотрим, что я сделал в каждой из них:

1. `shorten_url(request)`: Эта функция представления обрабатывает запросы на сокращение URL. Вот что я сделал в этой функции:
   - Если запрос исполнен методом POST, то я создаю экземпляр формы `URLForm` на основе данных из запроса.
   - Проверяете, что форма валидна, и если это так, я создаю сериализатор `TokenSerializer`, передавая ему оригинальный URL.
   - Проверяете, что сериализатор тоже валиден, и сохраняете токен (сокращенный URL) и код состояния.
   - Возвращаю рендеринг страницы 'shorten_form.html' с формой и сокращенным кодом (если он был успешно создан).

2. `redirect_original(request, short_url)`: Эта функция представления отвечает за перенаправление на оригинальный URL на основе сокращенного кода:
   - Я пытаюсь получить объект токена (сокращенного URL) из базы данных, используя значение `short_url`, переданное в запросе.
   - Если такой токен существует и активен, я увеличиваю счетчик запросов и сохраняете токен.
   - Затем я исполняю перенаправление на полный URL, связанный с этим токеном.
   - Если токен не существует (Token.DoesNotExist), возвращается ответ `HttpResponse` с сообщением "Сокращенная URL не найдена!".

Этот код предполагает, что у вас есть модель `Token`, форма `URLForm` и сериализатор `TokenSerializer`, которые используются для сокращения и перенаправления URL-ов. Я также использую шаблон 'shorten_form.html' для отображения формы в функции `shorten_url`.


7. Тестирование

Тесты:
- Написаны тесты для модели, формы, сериализатора и представлений.
- Проверяется корректность работы каждой части проекта.

В файле `test.py` я создал набор тестов для вашего Django-проекта. Давайте рассмотрим, что я сделал в каждом классе тестов:

1. `TokenModelTestCase`: Этот класс тестов предназначен для проверки модели `Token`. Я создал два метода тестирования:

   - `test_create_token`: Я создаю объект `Token` с определенными значениями атрибутов и затем проверяете, что созданный объект имеет правильные значения атрибутов.

2. `URLFormTestCase`: В этом классе тестов проверяется форма `URLForm`, используемая в вашем проекте для валидации URL. Я создал два метода тестирования:

   - `test_valid_form`: Я создаю объект `URLForm` с корректными данными и проверяете, что форма считается валидной.
   - `test_invalid_form`: Я создаю объект `URLForm` с некорректными данными и проверяете, что форма считается невалидной.

3. `TokenSerializerTestCase`: В этом классе тестов проверяется сериализатор `TokenSerializer`. Я создал два метода тестирования:

   - `test_create_token_with_short_url`: Я создаю данные для сериализатора, включая `short_url`, и проверяете, что сериализатор считается валидным. Затем я создаю объект `Token` через сериализатор и проверяете результат.
   - `test_create_token_without_short_url`: Я создаю данные для сериализатора без `short_url` и проверяете, что сериализатор считается валидным. Затем я создаю объект `Token` через сериализатор и проверяете результат.

4. `ViewsTestCase`: Этот класс тестов предназначен для проверки представлений (views) вашего проекта. Я создал три метода тестирования:

   - `test_shorten_url_view_get`: Я проверяете, что GET-запрос к представлению `shorten_url` возвращает статус код 200 (успешный запрос).
   - `test_shorten_url_view_post_valid_form`: Я проверяете, что POST-запрос к представлению `shorten_url` с корректной формой возвращает статус код 200 (успешный запрос).
   - `test_redirect_original_view_valid_short_url`: Я создаю объект `Token` с корректными данными, а затем проверяете, что GET-запрос к представлению `redirect_original` с корректным `short_url` приводит к редиректу (статус код 302).

Эти тесты помогут нам удостовериться, что основная функциональность вашего проекта работает корректно и соответствует ожиданиям. Я можете запустить эти тесты с помощью команды `python manage.py test`, чтобы убедиться в их успешном исполнен ии.


8. Защита данных и безопасность

Обеспечение безопасности:

- Данные валидируются на этапе ввода пользователем и перед сохранением.
- Генерация `short_url` происходит с учетом уникальности.
- Обработка исключений при некорректных данных.

9. Развитие проекта

Планы по доработке:

- Добавление пользовательских учетных записей и аутентификации.
- Создание пользовательских ссылок и управление ими.
- Расширение функциональности API.

10. Завершение и вопросы

Завершение:

- Проект предоставляет удобный способ сокращения и управления URL-ами.
- Открыт для доработок и улучшений.

Вопросы:

- Готов ответить на вопросы аудитории.
